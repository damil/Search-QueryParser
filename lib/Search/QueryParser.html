<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Search::QueryParser - parses a query string into a data structure
suitable for external search engines</title>

<style>

/* for the MasterTOC modules list */
.blend {
   color: #FFFFFF;
   text-decoration: underline;
}

/* standard elements */
body {
   background: #FFFFFF;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-weight: normal;
   font-size: 70%;
}
   
td {
   font-size: 70%;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-weight: normal;
   text-decoration: none;
}

input {
   font-size: 12px;
}

select {
   font-size: 12px;
}

p {
   color: #000000;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-weight: normal;
   padding-left: 1em;
}

p.code {
   padding-left: .1em;
}

.likepre {
   font-size: 120%;
   border: 1px groove #006000;
   background: #EEFFCC;
   padding-top: 1em;
   padding-bottom: 1em;
   white-space: pre;
}

blockquote {
   color: #000000;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-weight: normal;
}

dl {
   color: #000000;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-weight: normal;
}

dt {
   color: #000000;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-weight: normal;
   padding-left: 2em;
}

ul {
   color: #000000;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-weight: normal;
}

li {
   font-size: 110%;
}


ol {
   color: #000000;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-weight: normal;
}

h1 {
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-size: 18px;
   font-weight: bold;
   color: #DC143C;
/*
   color: #19881D;
*/
}

h2 {
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-size: 13px;
   font-weight: bold;
   color: #DC143C;
/*
   background-color: #EAE2BB;
   background-color: #EEE8AE;
*/
}

h3 {
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-size: 12px;
   font-weight: bold;
   color: #DC143C;
   border-left: 0.2em solid darkGreen;
   padding-left: 0.5em;
}        

h4 {
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-size: 11px;
   font-weight: bold;
   color: #DC143C;
   background: #ffffff;
   border: 1px groove black;
   padding: 2px, 0px, 2px, 1em;
}    

pre {
   font-size: 120%;
/*    background: #EEFFCC;
   background: #CCFFD9;
*/
   border: 1px groove #006000;
   background: #FFDAB9;
   padding-top: 1em;
   padding-bottom: 1em;
   white-space: pre;
}

hr {
   border: 1px solid #006000;
}

tt {
   font-size: 120%;
}

code {
   font-size: 120%;
   background: #90EE90;
   border: 0px solid black;
   padding: 0px, 4px, 0px, 4px;
}

kbd {
   font-size: 120%;
}
 
/* default links */

a:link {
/*
   color: #B82619;
*/
   color: #0000CD;
   text-decoration: underline;
}

a:visited {
/*
   color: #80764F;
*/
   color: #8B4513;
   text-decoration: underline;
}

a:hover {
   color: #000000;
   text-decoration: underline;
}

a:active {
/*
   color: #B82619;
*/
   color: #00525C;
   text-decoration: underline;
   /* font-weight: bold; */
}

/* crap */
td.block {
   font-size: 10pt;
/*
   background: #EAE2BB;
   background: #4EBF51;
   background: #97EB97;
   background: #D3FF8C;
   background: #AED9B1;
   background: #AEFFB1;
   background: #BBEAC8;
   background: #94B819;
*/
   background: #FFA500;
   color: #000080;
   border: 1px dotted #006000;
   font-weight: bold;
}  


</style>


<link rev="made" href="mailto:" />
</head>

<body>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#query_string">QUERY STRING</a></li>
	<ul>

		<li><a href="#sign_prefix">Sign prefix</a></li>
		<li><a href="#field_name_and_comparison_operator">Field name and comparison operator</a></li>
		<li><a href="#value">Value</a></li>
		<li><a href="#boolean_connectors">Boolean connectors</a></li>
	</ul>

	<li><a href="#methods">METHODS</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright_and_license">COPYRIGHT AND LICENSE</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Search::QueryParser - parses a query string into a data structure
suitable for external search engines</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  my $qp = new Search::QueryParser;
  my $s = '+mandatoryWord -excludedWord +field:word &quot;exact phrase&quot;';
  my $query = $qp-&gt;parse($s)  or die &quot;Error in query : &quot; . $qp-&gt;err;
  $someIndexer-&gt;search($query);</pre>
<pre>
  # query with comparison operators and implicit plus (second arg is true)
  $query = $qp-&gt;parse(&quot;txt~'^foo.*' date&gt;='01.01.2001' date&lt;='02.02.2002'&quot;, 1);</pre>
<pre>
  # boolean operators (example below is equivalent to &quot;+a +(b c) -d&quot;)
  $query = $qp-&gt;parse(&quot;a AND (b OR c) AND NOT d&quot;);</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This module parses a query string into a data structure to be handled
by external search engines.  For examples of such engines, see
<a href="c:/perl/html/site/lib/File/Tabular.html">the File::Tabular manpage</a> and <a href="c:/perl/html/site/lib/Search/Indexer.html">the Search::Indexer manpage</a>.</p>
<p>The query string can contain simple terms, ``exact phrases'', field
names and comparison operators, '+/-' prefixes, parentheses, and
boolean connectors.</p>
<p>The parser can be parameterized by regular expressions for specific
notions of ``term'', ``field name'' or ``operator'' ; see the <a href="#item_new">new</a>
method. The parser has no support for lemmatization or other term
transformations : these should be done externally, before passing the
query data structure to the search engine.</p>
<p>The data structure resulting from a parsed query is a tree of terms
and operators, as described below in the <a href="#item_parse">parse</a> method.  The
interpretation of the structure is up to the external search engine
that will receive the parsed query ; the present module does not make
any assumption about what it means to be ``equal'' or to ``contain'' a
term.</p>
<p>
</p>
<hr />
<h1><a name="query_string">QUERY STRING</a></h1>
<p>The query string is decomposed into ``items'', where 
each item has an optional sign prefix, 
an optional field name and comparison operator, 
and a mandatory value.</p>
<p>
</p>
<h2><a name="sign_prefix">Sign prefix</a></h2>
<p>Prefix '+' means that the item is mandatory.
Prefix '-' means that the item must be excluded.
No prefix means that the item will be searched
for, but is not mandatory.</p>
<p>As far as the result set is concerned, 
<code>+a +b c</code> is strictly equivalent to <code>+a +b</code> : the search engine will
return documents containing both terms 'a' and 'b', and possibly
also term 'c'. However, if the search engine also returns
relevance scores, query <code>+a +b c</code> might give a better score
to documents containing also term 'c'.</p>
<p>See also section <a href="#boolean_connectors">Boolean connectors</a> below, which is another
way to combine items into a query.</p>
<p>
</p>
<h2><a name="field_name_and_comparison_operator">Field name and comparison operator</a></h2>
<p>Internally, each query item has a field name and comparison 
operator; if not written explicitly in the query, these
take default values <code>''</code> (empty field name) and 
<code>':'</code> (colon operator).</p>
<p>Operators have a left operand (the field name) and 
a right operand (the value to be compared with);
for example, <code>foo:bar</code> means ``search documents containing 
term 'bar' in field 'foo''', whereas <code>foo=bar</code> means 
``search documents where field 'foo' has exact value 'bar'''.</p>
<p>Here is the list of admitted operators with their intended meaning :</p>
<dl>
<dt><strong><a name="item__3a"><code>:</code></a></strong><br />
</dt>
<dd>
treat value as a term to be searched within field. 
This is the default operator.
</dd>
<p></p>
<dt><strong><a name="item__7e_or__3d_7e"><code>~</code> or <code>=~</code></a></strong><br />
</dt>
<dd>
treat value as a regex; match field against the regex.
</dd>
<p></p>
<dt><strong><a name="item__21_7e"><code>!~</code></a></strong><br />
</dt>
<dd>
negation of above
</dd>
<p></p>
<dt><strong><a name="item__3d_3d_or__3d_2c__3c_3d_2c__3e_3d_2c__21_3d_2c__3c"><code>==</code> or <code>=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code></a></strong><br />
</dt>
<dd>
classical relational operators
</dd>
<p></p></dl>
<p>Operators <a href="#item__3a"><code>:</code></a>, <code>~</code>, <code>=~</code> and <a href="#item__21_7e"><code>!~</code></a> admit an empty 
left operand (so the field name will be <code>''</code>).
Search engines will usually interpret this as 
``any field'' or ``the whole data record''.</p>
<p>
</p>
<h2><a name="value">Value</a></h2>
<p>A value (right operand to a comparison operator) can be</p>
<ul>
<li></li>
just a term (as recognized by regex <a href="#item_rxterm"><code>rxTerm</code></a>, see <a href="#item_new">new</a> method below)
<p></p>
<li></li>
A quoted phrase, i.e. a collection of terms within
single or double quotes.
<p>Quotes can be used not only for ``exact phrases'', but also
to prevent misinterpretation of some values : for example
<code>-2</code> would mean ``value '2' with prefix '-''', 
in other words ``exclude term '2''', so if you want to search for
value -2, you should write <code>&quot;-2&quot;</code> instead. In the 
last example of the synopsis, quotes were used to
prevent splitting of dates into several search terms.</p>
<p></p>
<li></li>
a subquery within parentheses.
Field names and operators distribute over parentheses, so for 
example <code>foo:(bar bie)</code> is equivalent to 
<code>foo:bar foo:bie</code>. 
Nested field names such as <code>foo:(bar:bie)</code> are not allowed.
Sign prefixes do not distribute : <code>+(foo bar) +bie</code> is not
equivalent to <code>+foo +bar +bie</code>.
<p></p></ul>
<p>
</p>
<h2><a name="boolean_connectors">Boolean connectors</a></h2>
<p>Queries can contain boolean connectors 'AND', 'OR', 'NOT'
(or their equivalent in some other languages).
This is mere syntactic sugar for the '+' and '-' prefixes :
<code>a AND b</code> is translated into <code>+a +b</code>;
<code>a OR b</code> is translated into <code>(a b)</code>;
<code>NOT a</code> is translated into <code>-a</code>.
<code>+a OR b</code> does not make sense, 
but it is translated into <code>(a b)</code>, under the assumption
that the user understands ``OR'' better than a 
'+' prefix.
<code>-a OR b</code> does not make sense either, 
but has no meaningful approximation, so it is rejected.</p>
<p>Combinations of AND/OR clauses must be surrounded by
parentheses, i.e. <code>(a AND b) OR c</code> or <code>a AND (b OR c)</code> are
allowed, but <code>a AND b OR c</code> is not.</p>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="item_new">new</a></strong><br />
</dt>
<dd>
<pre>
  new(rxTerm   =&gt; qr/.../, rxOp =&gt; qr/.../, ...)</pre>
</dd>
<dd>
<p>Creates a new query parser, initialized with (optional) regular
expressions :</p>
</dd>
<dl>
<dt><strong><a name="item_rxterm">rxTerm</a></strong><br />
</dt>
<dd>
Regular expression for matching a term.
Of course it should not match the empty string.
Default value is <code>qr/[^\s()]+/</code>.
A term should not be allowed to include parenthesis, otherwise the parser
might get into trouble.
</dd>
<p></p>
<dt><strong><a name="item_rxfield">rxField</a></strong><br />
</dt>
<dd>
Regular expression for matching a field name.
Default value is <code>qr/\w+/</code> (meaning of <code>\w</code> according to <code>use locale</code>).
</dd>
<p></p>
<dt><strong><a name="item_rxop">rxOp</a></strong><br />
</dt>
<dd>
Regular expression for matching an operator.
Default value is <code>qr/==|&lt;=|&gt;=|!=|=~|!~|:|=|&lt;|&gt;|~/</code>.
Note that the longest operators come first in the regex, because
``alternatives are tried from left to right'' 
(see <a href="c:/perl/html/lib/Pod/perlre.html#version_8_regular_expressions">Version 8 Regular Expressions in the perlre manpage</a>) :
this is to avoid <code>a&lt;=3</code> being parsed as
<code>a &lt; '=3'</code>.
</dd>
<p></p>
<dt><strong><a name="item_rxopnofield">rxOpNoField</a></strong><br />
</dt>
<dd>
Regular expression for a subset of the operators
which admit an empty left operand (no field name).
Default value is <code>qr/=~|!~|~|:/</code>.
Such operators can be meaningful for comparisons
with ``any field'' or with ``the whole record'' ;
the precise interpretation depends on the search engine.
</dd>
<p></p>
<dt><strong><a name="item_rxand">rxAnd</a></strong><br />
</dt>
<dd>
Regular expression for boolean connector AND.
Default value is <code>qr/AND|ET|UND|E/</code>.
</dd>
<p></p>
<dt><strong><a name="item_rxor">rxOr</a></strong><br />
</dt>
<dd>
Regular expression for boolean connector OR.
Default value is <code>qr/OR|OU|ODER|O/</code>.
</dd>
<p></p>
<dt><strong><a name="item_rxnot">rxNot</a></strong><br />
</dt>
<dd>
Regular expression for boolean connector NOT.
Default value is <code>qr/NOT|PAS|NICHT|NON/</code>.
</dd>
<p></p></dl>
<dt><strong><a name="item_parse">parse</a></strong><br />
</dt>
<dd>
<pre>
  $q = $queryParser-&gt;parse($queryString, $implicitPlus);</pre>
</dd>
<dd>
<p>Returns a data structure corresponding to the parsed string.
The second argument is optional; if true, it adds an implicit
'+' in front of each term without prefix, so
<a href="#item_parse"><code>parse(&quot;+a b c -d&quot;, 1)</code></a> is equivalent to <a href="#item_parse"><code>parse(&quot;+a +b +c -d&quot;)</code></a>.
This is often seen in common WWW search engines
as an option ``match all words''.</p>
</dd>
<dd>
<p>The return value has following structure :</p>
</dd>
<dd>
<pre>
  { '+' =&gt; [{field=&gt;'f1', op=&gt;':', value=&gt;'v1'}, 
            {field=&gt;'f2', op=&gt;':', value=&gt;'v2'}, ...],
    ''  =&gt; [...],
    '-' =&gt; [...]
  }</pre>
</dd>
<dd>
<p>In other words, it is a hash ref with 3 keys <code>'+'</code>, <code>''</code> and <code>'-'</code>,
corresponding to the 3 sign prefixes (mandatory, ordinary or excluded
items). Each key holds either a ref to an array of items, or 
<code>undef</code> (no items with this prefix in the query).</p>
</dd>
<dd>
<p>An <em>item</em> is a hash ref containing</p>
</dd>
<dl>
<dt><strong><a name="item_field"><code>field</code></a></strong><br />
</dt>
<dd>
scalar, field name (may be the empty string)
</dd>
<p></p>
<dt><strong><a name="item_op"><code>op</code></a></strong><br />
</dt>
<dd>
scalar, operator
</dd>
<p></p>
<dt><strong><a name="item_value"><code>value</code></a></strong><br />
</dt>
<dd>
Either
</dd>
<ul>
<li></li>
a scalar (simple term), or
<p></p>
<li></li>
an array ref (list of terms, corresponding to an ``exact phrase''
in the query), or
<p></p>
<li></li>
a recursive ref to another query structure. In that case, 
<a href="#item_op"><code>op</code></a> is necessarily <code>'()'</code> ; this corresponds
to a subquery in parentheses.
<p></p></ul>
</dl>
<p>In case of a parsing error, <a href="#item_parse"><code>parse</code></a> returns <code>undef</code>;
method <a href="#item_err">err</a> can be called to get an explanatory message.</p>
<dt><strong><a name="item_err">err</a></strong><br />
</dt>
<dd>
<pre>
  $msg = $queryParser-&gt;err;</pre>
</dd>
<dd>
<p>Message describing the last parse error</p>
</dd>
<dt><strong><a name="item_unparse">unparse</a></strong><br />
</dt>
<dd>
<pre>
  $s = $queryParser-&gt;unparse($query);</pre>
</dd>
<dd>
<p>Returns a string representation of the <code>$query</code> data structure.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Laurent Dami, &lt;laurent.dami AT etat ge ch&gt;</p>
<p>
</p>
<hr />
<h1><a name="copyright_and_license">COPYRIGHT AND LICENSE</a></h1>
<p>Copyright (C) 2005 by Laurent Dami.</p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</body>

</html>
